package shop.mtcoding.bank.config.jwt;

/*
 * SECRET 은 노출되어서는 안된다.
 * 환경변수, 클라우드 서비스와 같은 곳에 등록해놓고 꺼내쓰는 방식으로 사용해야 한다.
 * 
 * 리플래시 토큰 : 일주일이 지나서 액세스 토큰이 만료되었을 때 이를 갱신해주는 토큰인데 이는 이번에 사용하지 않는다.
 */
public interface JwtVO {
    public static final String SECRET = "메타코딩"; // HS256 (대칭키 - 키 하나로 암호화)
    public static final int EXPIRATION_TIME = 1000 * 60 * 60 * 24 * 7; // 키 만료시간 일주일
    public static final String TOKEN_PREFIX = "Bearer "; // 뒤에 한 칸 공백이 필요하다.
    public static final String HEADER = "Authorization"; // 헤더에 들어갈 문자열
    /*
     * 서버가 만들어지고 난 뒤엔 앱, 또는 리액트와 같은 프론트엔드와 통신을 주고받아야 한다.
     * 이때 로그인 요청이 들어온다고 가정하면, 기존에 form 방식을 사용하지 않을 것이다.
     * 기존의 form 방식은 로그인 시 서버측으로 데이터를 전달할 때 x-www-form-urlencoded 방식으로 데이터를 전송하는데
     * 우리는 이게 아닌 json 타입으로 데이터를 주고받을 것이다.
     * 
     * 로그인 시 json 타입으로 데이터를 서버측으로 전송해주면 서버측은 post 방식으로 /login URI 로 요청이 들어오는 순간,
     * 시큐리티의 UsernamePasswordAuthenticationFilter 가 동작해서 필요한 동작을 처리하게 된다.
     * 그런데 기존의 방식으로는 x-www-form-urlencoded 방식으로 들어온 데이터를 처리하게 되기 때문에 이 필터에 손을 대줄 필요가
     * 있다.
     * 로그인을 하고 나면 서버에서는 전송된 데이터가 DB에 존재하는지 확인하고 난 다음, 데이터가 존재할 경우 JWT 토큰을 만들어주게 되는데
     * 이 토큰은 중간에 공격자에 의해 훼손, 변조되는 것을 방지해야 하기 때문에 HS256 방식으로 암호화 해줘야 한다.
     * 이렇게 암호화가 되고 나면 로그인 요청 수행결과를 클라이언트에게 돌려줄 때 만들어진 JWT 토큰을 헤더에 실어서 보내주게 되고
     * 그 다음부터 클라이언트는 서버로 요청을 보낼때 서버로부터 받은 JWT 토큰을 들고 요청을 하게된다.
     * 이때 서버는 클라이언트로부터 넘어온 암호화된 JWT 토큰을 확인만 해주면 된다.
     * 
     * 이 과정에서 HS256 은 서버만 가지고 있어도 된다. 클라이언트는 이를 굳이 가지고 있을 필요가 없다. 키가 하나만 있어도 된다는
     * 뜻이다.(대칭키)
     * 
     * HS256 대신 RSA 를 사용한다고 가정해보자.
     * RSA 는 두 가지 키를 다룬다. 공개 키와 비밀 키가 바록 그것이다.
     * 비밀 키는 서버가 가지고 있는 상태에서 JWT 토큰을 RSA 로 암호화 한 다음 이 토큰을 헤더에 담아서 클라이언트에게 응답을 돌려준다.
     * 클라이언트는 이 토큰이 정상적인 토큰인지 공개 키로 검증할 필요는 없다. 클라이언트 입장에서는 서버의 공개 키가 사실상 필요없는 것이다.
     * 그냥 이 토큰을 가지고 있다가 서버에게 요청을 보낼 때 토큰을 함께 실어보내면 될 일이고
     * 서버는 이 토큰을 받아서 서버가 가지고 있는 공개 키를 이용해 토큰을 열어서 정상적인 토큰인지 아닌지 확인하면 될 뿐이다.
     * 서버와 클라이언트 둘이 각각 키를 가지고 있어야 하는 상황이라면 대칭 키를 사용할 수 없지만
     * 서버 혼자서 토큰을 만들고 암호화하고 검증하는 과정을 모두 수행할 것이기 때문에 키가 하나만 있어도 된다. 대칭 키를 활용하는게
     * 가능한것이다.
     * 
     * 이번엔 JWT 토큰을 HS256 방식으로 암호화 할것인데, 이때 우리쪽의 서버가 가지는 키가 바로
     * JwtVO 클래스에서 만들어준 SECRET 이고, 이는 비밀 키로서 절대 외부에 노출되어서는 안된다.
     * 
     * 실제로는 이번과 같이 직접 값을 할당해주는 것이 아니라 환경변수를 사용하던가 DB 에서 가져오던가 하는 식으로
     * 외부로부터 키 값을 끌어와야 한다.
     */
}
